<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>水立方體強化完整版</title>
<style>
body{
  margin:0;
  background: linear-gradient(
    to bottom,
    hsl(205,60%,35%) 0%,
    hsl(205,50%,20%) 40%,
    hsl(205,45%,12%) 100%
  );
  overflow:hidden;
}
canvas{ display:block; }
</style>
</head>
<body>
<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

function resize(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

const mapRows = 8;
const mapCols = 8;

const topMap = [
  [1,1,1,1,1,1,1,1],
  [1,1,1,0,0,1,1,1],
  [1,1,0,0,0,0,1,1],
  [1,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0],
  [1,0,0,0,0,0,0,0],
  [1,0,0,0,0,0,0,0],
  [1,0,0,0,0,0,0,0],
];

let time = 0;

function isoToScreen(x, y, z, tileW, tileH, tileZ){
  return {
    x: (x - y) * tileW / 2,
    y: (x + y) * tileH / 2 - z * tileZ
  };
}

function drawCubeShell(x,y,z,tileW,tileH,tileZ,colors,heightOffset=0,alpha=1){

  ctx.globalAlpha = alpha;

  const pos = isoToScreen(x,y,z,tileW,tileH,tileZ);
  const centerX = canvas.width/2;
  const centerY = canvas.height * 0.6;

  const sx = pos.x + centerX;
  const sy = pos.y + centerY - heightOffset;

  // 左面
  ctx.fillStyle = colors.left;
  ctx.beginPath();
  ctx.moveTo(sx - tileW/2, sy - tileH/2 - tileZ);
  ctx.lineTo(sx - tileW/2, sy - tileH/2);
  ctx.lineTo(sx, sy);
  ctx.lineTo(sx, sy - tileZ);
  ctx.closePath();
  ctx.fill();

  // 右面
  ctx.fillStyle = colors.right;
  ctx.beginPath();
  ctx.moveTo(sx + tileW/2, sy - tileH/2 - tileZ);
  ctx.lineTo(sx + tileW/2, sy - tileH/2);
  ctx.lineTo(sx, sy);
  ctx.lineTo(sx, sy - tileZ);
  ctx.closePath();
  ctx.fill();

  ctx.globalAlpha = 1;
}

function getWaterVisual(z, maxDepth){
  const depthRatio = (maxDepth - z) / maxDepth;
  const baseHue = 205;
  const lightness = 72 - depthRatio * 45;
  const saturation = 75 - depthRatio * 30;
  const alpha = 0.85 - depthRatio * 0.55;

  return {
    colors:{
      left:`hsl(${baseHue}, ${saturation}%, ${lightness - 12}%)`,
      right:`hsl(${baseHue}, ${saturation}%, ${lightness - 20}%)`
    },
    alpha: alpha
  };
}

/* ========================
   微氣泡系統
======================== */

const bubbles = [];
const bubbleCount = 180;

function createBubbles(mapLayer){
  bubbles.length = 0;
  for(let i=0;i<bubbleCount;i++){
    bubbles.push({
      x: Math.random()*mapCols,
      y: Math.random()*mapRows,
      z: Math.random()*mapLayer,
      speed: 0.01 + Math.random()*0.03,
      size: 1 + Math.random()*2,
      drift: Math.random()*0.02
    });
  }
}

function updateBubbles(mapLayer){
  bubbles.forEach(b=>{
    b.z += b.speed;
    b.x += Math.sin(time*0.5 + b.z)*b.drift;
    if(b.z >= mapLayer){
      b.z = 0;
      b.x = Math.random()*mapCols;
      b.y = Math.random()*mapRows;
    }
  });
}

function drawBubbles(tileW,tileH,tileZ,mapLayer){
  ctx.save();
  ctx.globalCompositeOperation="lighter";

  bubbles.forEach(b=>{
    const pos = isoToScreen(b.x,b.y,b.z,tileW,tileH,tileZ);
    const centerX = canvas.width/2;
    const centerY = canvas.height * 0.6;

    const sx = pos.x + centerX;
    const sy = pos.y + centerY;

    const depthRatio = b.z/mapLayer;

    ctx.globalAlpha = 0.15 + (1-depthRatio)*0.25;

    ctx.beginPath();
    ctx.arc(sx, sy - tileZ/2, b.size, 0, Math.PI*2);
    ctx.fillStyle="rgba(255,255,255,0.8)";
    ctx.fill();
  });

  ctx.restore();
}

function render(){

  time += 0.05;
  ctx.clearRect(0,0,canvas.width,canvas.height);

  const tileW = Math.min(canvas.width, canvas.height)/8;
  const tileH = tileW/2;
  const tileZ = tileW/2;

  const reservedTopLayers = 15;
  const totalLayers = Math.ceil(canvas.height / tileZ);
  const mapLayer = totalLayers - reservedTopLayers - 1;

  if(bubbles.length===0){
    createBubbles(mapLayer);
  }

  for(let z=0; z<=mapLayer; z++){
    for(let y=0; y<mapRows; y++){
      for(let x=0; x<mapCols; x++){

        if(z === mapLayer && topMap[y][x]===1){
          continue; // 地圖層不畫水
        }

        const water = getWaterVisual(z,mapLayer);

        let waveOffset = 0;
        if(z===mapLayer){
          const amplitude = tileZ*0.18;
          waveOffset = Math.sin(time + x*0.6 + y*0.6)*amplitude;
        }

        let edgeBoost=0;
        let edgeAlphaBoost=0;

        if(x===0 || x===mapCols-1){
          edgeBoost=8;
          edgeAlphaBoost=0.12;
        }

        const boostedColors={
          left:`hsl(205,80%,${60+edgeBoost}%)`,
          right:`hsl(205,80%,${55+edgeBoost}%)`
        };

        drawCubeShell(
          x,y,z,
          tileW,tileH,tileZ,
          boostedColors,
          waveOffset,
          water.alpha+edgeAlphaBoost
        );
      }
    }
  }

  updateBubbles(mapLayer);
  drawBubbles(tileW,tileH,tileZ,mapLayer);

  requestAnimationFrame(render);
}

render();
</script>
</body>
</html>