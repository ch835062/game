<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>旋轉大立方體世界</title>
<style>
body{
  margin:0;
  background:#111;
  overflow:hidden;
}
canvas{
  display:block;
}
</style>
</head>
<body>
<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

function resize(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

// ===== 地圖 =====
const mapSize = 8;

const topMap = [
  [1,1,1,1,1,1,1,1],
  [1,1,1,0,0,1,1,1],
  [1,1,0,0,0,0,1,1],
  [1,0,0,0,0,0,0,1],
  [1,1,0,0,0,0,1,1],
  [1,1,1,0,0,1,1,1],
  [1,1,1,1,1,1,1,1],
  [1,1,1,1,1,1,1,1],
];

let angle = 0;

function rotateY(x,z,angle){
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  return {
    x: x*cos - z*sin,
    z: x*sin + z*cos
  };
}

function project(x,y,z,scale){
  const perspective = 800;
  const factor = perspective / (perspective + z);
  return {
    x: x * factor * scale + canvas.width/2,
    y: y * factor * scale + canvas.height/2,
    scale: factor
  };
}

function drawCube(cx,cy,cz,size,type){

  const hs = size/2;

  let vertices = [
    [-hs,-hs,-hs],[hs,-hs,-hs],[hs,hs,-hs],[-hs,hs,-hs],
    [-hs,-hs,hs],[hs,-hs,hs],[hs,hs,hs],[-hs,hs,hs]
  ];

  let projected = [];

  vertices.forEach(v=>{
    let rx = v[0] + cx;
    let ry = v[1] + cy;
    let rz = v[2] + cz;

    const r = rotateY(rx,rz,angle);
    rx = r.x;
    rz = r.z;

    projected.push(project(rx,ry,rz,1));
  });

  const faces = [
    [0,1,2,3], // back
    [4,5,6,7], // front
    [0,1,5,4], // top
    [2,3,7,6], // bottom
    [1,2,6,5], // right
    [0,3,7,4]  // left
  ];

  const colors = type===1
    ? ["#2e7d32","#4caf50","#388e3c","#2e7d32","#1b5e20","#1b5e20"]
    : ["#1565c0","#2196f3","#1976d2","#1565c0","#0d47a1","#0d47a1"];

  faces.forEach((face,i)=>{
    ctx.beginPath();
    ctx.moveTo(projected[face[0]].x, projected[face[0]].y);
    face.forEach(idx=>{
      ctx.lineTo(projected[idx].x, projected[idx].y);
    });
    ctx.closePath();

    if(type===0) ctx.globalAlpha = 0.55;
    else ctx.globalAlpha = 1;

    ctx.fillStyle = colors[i];
    ctx.fill();
  });

  ctx.globalAlpha = 1;
}

function render(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  const size = Math.min(canvas.width, canvas.height)/25;

  const reservedTop = 10;
  const totalLayers = 20;
  const mapLayer = totalLayers - reservedTop - 1;

  let cubes = [];

  for(let z=0; z<totalLayers; z++){
    for(let y=0; y<mapSize; y++){
      for(let x=0; x<mapSize; x++){

        let type = null;

        if(z === mapLayer){
          type = topMap[y][x];
        }
        else if(z < mapLayer){
          type = 0;
        }
        else{
          continue;
        }

        cubes.push({
          x: (x-mapSize/2)*size*1.1,
          y: (y-mapSize/2)*size*1.1,
          z: (z-totalLayers/2)*size*1.1,
          type
        });
      }
    }
  }

  cubes.sort((a,b)=>b.z-a.z);

  cubes.forEach(c=>{
    drawCube(c.x,c.y,c.z,size,c.type);
  });

  angle += 0.01;
  requestAnimationFrame(render);
}

render();
</script>
</body>
</html>