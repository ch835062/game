<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>3D 釣魚世界</title>

<style>
body{
  margin:0;
  background:#000;
  overflow:hidden;
  display:flex;
  justify-content:center;
  align-items:center;
  height:100vh;
}

.scene{
  perspective: 1200px;
  width:100vw;
  height:100vh;
  display:flex;
  justify-content:center;
  align-items:center;
}

.cube{
  position:relative;
  transform-style: preserve-3d;
  transition: transform 1.2s ease;
}

.face{
  position:absolute;
  background: rgba(0,150,255,0.05);
  border:1px solid rgba(0,200,255,0.25);
  box-shadow:0 0 25px rgba(0,150,255,0.3);
  backdrop-filter: blur(4px);
}

.face canvas{
  width:100%;
  height:100%;
  display:block;
}
</style>
</head>
<body>

<div class="scene">
  <div class="cube" id="cube">
    <div class="face top">
      <canvas id="mapCanvas"></canvas>
    </div>
    <div class="face front">
      <canvas id="shallowCanvas"></canvas>
    </div>
    <div class="face right">
      <canvas id="deepCanvas"></canvas>
    </div>
  </div>
</div>

<script>
const cube = document.getElementById("cube");
const topFace = document.querySelector(".top");
const frontFace = document.querySelector(".front");
const rightFace = document.querySelector(".right");

const mapCanvas = document.getElementById("mapCanvas");
const ctx = mapCanvas.getContext("2d");

// ===== 立方體尺寸 RWD =====
function resizeCube(){

  const size = Math.min(window.innerWidth, window.innerHeight) * 0.7;

  const topHeight = size * 0.25;
  const shallowHeight = size * 0.25;
  const deepHeight = size * 0.45;

  const totalHeight = topHeight + shallowHeight + deepHeight;

  cube.style.width = size + "px";
  cube.style.height = totalHeight + "px";

  topFace.style.width = size + "px";
  topFace.style.height = topHeight + "px";
  topFace.style.transform =
    `rotateX(90deg) translateZ(${totalHeight/2}px)`;

  frontFace.style.width = size + "px";
  frontFace.style.height = totalHeight + "px";
  frontFace.style.transform =
    `translateZ(${size/2}px)`;

  rightFace.style.width = size + "px";
  rightFace.style.height = totalHeight + "px";
  rightFace.style.transform =
    `rotateY(90deg) translateZ(${size/2}px)`;

  cube.style.transform =
    "rotateX(20deg) rotateY(45deg)";

  resizeMapCanvas();
}

window.addEventListener("resize", resizeCube);

// ===== 等角地圖 =====

const map = [
  [1,1,1,1,1,1],
  [1,1,0,0,1,1],
  [1,0,0,0,0,1],
  [1,1,0,0,1,1],
  [1,1,1,1,1,1],
];

function resizeMapCanvas(){
  mapCanvas.width = mapCanvas.clientWidth;
  mapCanvas.height = mapCanvas.clientHeight;
}

function isoToScreen(x,y,tileW,tileH){
  return {
    x:(x-y)*tileW/2,
    y:(x+y)*tileH/2
  };
}

let time=0;

function drawMap(){

  ctx.clearRect(0,0,mapCanvas.width,mapCanvas.height);

  const tileW = mapCanvas.width / 6;
  const tileH = tileW/2;
  const height = tileW/2;

  const centerX = mapCanvas.width/2;
  const centerY = mapCanvas.height/2;

  for(let y=0;y<map.length;y++){
    for(let x=0;x<map[0].length;x++){

      const pos = isoToScreen(x,y,tileW,tileH);

      const sx = pos.x + centerX;
      const sy = pos.y + centerY;

      const wave = map[y][x]===0 ? Math.sin(time+x+y)*3 : 0;
      const h = map[y][x]===1 ? height : height/3;

      const topColor = map[y][x]===1 ? "#4caf50" : "#2196f3";
      const leftColor = map[y][x]===1 ? "#388e3c" : "#1976d2";
      const rightColor= map[y][x]===1 ? "#2e7d32" : "#1565c0";

      // top
      ctx.fillStyle = topColor;
      ctx.beginPath();
      ctx.moveTo(sx,sy-h+wave);
      ctx.lineTo(sx+tileW/2,sy-tileH/2-h+wave);
      ctx.lineTo(sx,sy-tileH-h+wave);
      ctx.lineTo(sx-tileW/2,sy-tileH/2-h+wave);
      ctx.closePath();
      ctx.fill();

      // left
      ctx.fillStyle = leftColor;
      ctx.beginPath();
      ctx.moveTo(sx-tileW/2,sy-tileH/2-h);
      ctx.lineTo(sx-tileW/2,sy-tileH/2);
      ctx.lineTo(sx,sy);
      ctx.lineTo(sx,sy-h);
      ctx.closePath();
      ctx.fill();

      // right
      ctx.fillStyle = rightColor;
      ctx.beginPath();
      ctx.moveTo(sx+tileW/2,sy-tileH/2-h);
      ctx.lineTo(sx+tileW/2,sy-tileH/2);
      ctx.lineTo(sx,sy);
      ctx.lineTo(sx,sy-h);
      ctx.closePath();
      ctx.fill();
    }
  }

  time+=0.05;
  requestAnimationFrame(drawMap);
}

resizeCube();
drawMap();

</script>
</body>
</html>