<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>極簡水族箱模型展示版</title>
<style>
body{
  margin:0;
  background:#eef2f5;
  overflow:hidden;
}
canvas{ display:block; }
</style>
</head>
<body>
<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

function resize(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

const mapRows = 8;
const mapCols = 8;

let time = 0;

function isoToScreen(x, y, z, tileW, tileH, tileZ){
  return {
    x: (x - y) * tileW / 2,
    y: (x + y) * tileH / 2 - z * tileZ
  };
}

function drawCube(x,y,z,tileW,tileH,tileZ,colors,heightOffset=0,alpha=1){
  ctx.globalAlpha = alpha;

  const pos = isoToScreen(x,y,z,tileW,tileH,tileZ);
  const centerX = canvas.width/2;
  const centerY = canvas.height * 0.58;

  const sx = pos.x + centerX;
  const sy = pos.y + centerY - heightOffset;

  // 上面
  ctx.fillStyle = colors.top;
  ctx.beginPath();
  ctx.moveTo(sx, sy - tileZ);
  ctx.lineTo(sx + tileW/2, sy - tileH/2 - tileZ);
  ctx.lineTo(sx, sy - tileH - tileZ);
  ctx.lineTo(sx - tileW/2, sy - tileH/2 - tileZ);
  ctx.closePath();
  ctx.fill();

  // 左面
  ctx.fillStyle = colors.left;
  ctx.beginPath();
  ctx.moveTo(sx - tileW/2, sy - tileH/2 - tileZ);
  ctx.lineTo(sx - tileW/2, sy - tileH/2);
  ctx.lineTo(sx, sy);
  ctx.lineTo(sx, sy - tileZ);
  ctx.closePath();
  ctx.fill();

  // 右面
  ctx.fillStyle = colors.right;
  ctx.beginPath();
  ctx.moveTo(sx + tileW/2, sy - tileH/2 - tileZ);
  ctx.lineTo(sx + tileW/2, sy - tileH/2);
  ctx.lineTo(sx, sy);
  ctx.lineTo(sx, sy - tileZ);
  ctx.closePath();
  ctx.fill();

  ctx.globalAlpha = 1;
}

function getWaterVisual(z, maxDepth){
  const depthRatio = (maxDepth - z) / maxDepth;

  const baseHue = 200;
  const lightness = 80 - depthRatio * 35;
  const saturation = 50 - depthRatio * 20;
  const alpha = 0.65 - depthRatio * 0.35;

  return {
    colors:{
      top: `hsl(${baseHue}, ${saturation}%, ${lightness}%)`,
      left:`hsl(${baseHue}, ${saturation}%, ${lightness - 10}%)`,
      right:`hsl(${baseHue}, ${saturation}%, ${lightness - 18}%)`
    },
    alpha: alpha
  };
}

/* =========================
   微氣泡（柔和版）
========================= */

const bubbles = [];
const bubbleCount = 100;

function createBubbles(mapLayer){
  bubbles.length = 0;
  for(let i=0;i<bubbleCount;i++){
    bubbles.push({
      x: Math.random()*mapCols,
      y: Math.random()*mapRows,
      z: Math.random()*mapLayer,
      speed: 0.008 + Math.random()*0.02,
      size: 0.8 + Math.random()*1.5,
      drift: Math.random()*0.015
    });
  }
}

function updateBubbles(mapLayer){
  bubbles.forEach(b=>{
    b.z += b.speed;
    b.x += Math.sin(time*0.4 + b.z)*b.drift;
    if(b.z >= mapLayer){
      b.z = 0;
      b.x = Math.random()*mapCols;
      b.y = Math.random()*mapRows;
    }
  });
}

function drawBubbles(tileW,tileH,tileZ,mapLayer){
  bubbles.forEach(b=>{
    const pos = isoToScreen(b.x,b.y,b.z,tileW,tileH,tileZ);
    const centerX = canvas.width/2;
    const centerY = canvas.height * 0.58;

    const sx = pos.x + centerX;
    const sy = pos.y + centerY;

    const depthRatio = b.z/mapLayer;
    ctx.globalAlpha = 0.1 + (1-depthRatio)*0.2;

    ctx.beginPath();
    ctx.arc(sx, sy - tileZ/2, b.size, 0, Math.PI*2);
    ctx.fillStyle="rgba(255,255,255,0.7)";
    ctx.fill();
  });
  ctx.globalAlpha = 1;
}

/* ========================= */

function drawGlassFrame(tileW,mapLayer,tileZ){
  ctx.strokeStyle="rgba(255,255,255,0.7)";
  ctx.lineWidth=2;

  const width = tileW*mapCols/2;
  const height = tileZ*(mapLayer+1);

  const cx = canvas.width/2;
  const cy = canvas.height*0.58;

  ctx.strokeRect(cx-width, cy-height, width*2, height);

  // 底座
  ctx.fillStyle="#222";
  ctx.fillRect(cx-width-40, cy+10, width*2+80, 20);
}

function render(){

  time += 0.03;
  ctx.clearRect(0,0,canvas.width,canvas.height);

  const tileW = Math.min(canvas.width, canvas.height)/8;
  const tileH = tileW/2;
  const tileZ = tileW/2;

  const reservedTopLayers = 12;
  const totalLayers = Math.ceil(canvas.height / tileZ);
  const mapLayer = totalLayers - reservedTopLayers - 1;

  if(bubbles.length===0){
    createBubbles(mapLayer);
  }

  for(let z=0; z<=mapLayer; z++){
    for(let y=0; y<mapRows; y++){
      for(let x=0; x<mapCols; x++){

        const water = getWaterVisual(z,mapLayer);

        let waveOffset = 0;
        if(z===mapLayer){
          waveOffset = Math.sin(time + x*0.5 + y*0.5)* (tileZ*0.05);
        }

        drawCube(
          x,y,z,
          tileW,tileH,tileZ,
          water.colors,
          waveOffset,
          water.alpha
        );
      }
    }
  }

  updateBubbles(mapLayer);
  drawBubbles(tileW,tileH,tileZ,mapLayer);

  drawGlassFrame(tileW,mapLayer,tileZ);

  requestAnimationFrame(render);
}

render();
</script>
</body>
</html>