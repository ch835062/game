<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>2.5D 大湖地圖</title>
<style>
body{
  margin:0;
  background:#111;
  overflow:hidden;
}
canvas{ display:block; }
</style>
</head>
<body>
<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

function resize(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

// ===== 地圖尺寸加大 =====
const mapRows = 18;
const mapCols = 18;

// 0 = 水
// 1 = 陸地
const map = [];

for(let y=0; y<mapRows; y++){
  let row = [];
  for(let x=0; x<mapCols; x++){

    // 只保留右下角小區域為陸地
    if(x > mapCols-4 && y > mapRows-4){
      row.push(1);
    }else{
      row.push(0);
    }
  }
  map.push(row);
}

// ===== 等角轉換 =====
function isoToScreen(x, y, tileW, tileH){
  return {
    x: (x - y) * tileW / 2,
    y: (x + y) * tileH / 2
  };
}

// ===== 魚 =====
let fishes = [];
function createFish(){
  return {
    x: Math.random()*14,
    y: Math.random()*14,
    vx: (Math.random()-0.5)*0.02,
    vy: (Math.random()-0.5)*0.02,
  };
}
for(let i=0;i<8;i++) fishes.push(createFish());

let time = 0;

function drawTile(x, y, tileW, tileH, height, type){

  const pos = isoToScreen(x, y, tileW, tileH);

  const centerX = canvas.width/2;
  const centerY = 100; // 往上固定起點

  const screenX = pos.x + centerX;
  const screenY = pos.y + centerY;

  let wave = 0;
  if(type === 0){
    wave = Math.sin(time + x*0.5 + y*0.5) * 3;
  }

  const h = type === 1 ? height : height/4;

  // 上面
  ctx.fillStyle = type === 1 ? "#4caf50" : "#1e88e5";
  ctx.beginPath();
  ctx.moveTo(screenX, screenY - h + wave);
  ctx.lineTo(screenX + tileW/2, screenY - tileH/2 - h + wave);
  ctx.lineTo(screenX, screenY - tileH - h + wave);
  ctx.lineTo(screenX - tileW/2, screenY - tileH/2 - h + wave);
  ctx.closePath();
  ctx.fill();

  if(type === 1){
    ctx.fillStyle = "#2e7d32";
    ctx.beginPath();
    ctx.moveTo(screenX - tileW/2, screenY - tileH/2 - h);
    ctx.lineTo(screenX - tileW/2, screenY - tileH/2);
    ctx.lineTo(screenX, screenY);
    ctx.lineTo(screenX, screenY - h);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = "#1b5e20";
    ctx.beginPath();
    ctx.moveTo(screenX + tileW/2, screenY - tileH/2 - h);
    ctx.lineTo(screenX + tileW/2, screenY - tileH/2);
    ctx.lineTo(screenX, screenY);
    ctx.lineTo(screenX, screenY - h);
    ctx.closePath();
    ctx.fill();
  }
}

// ===== 魚 =====
function drawFish(tileW, tileH){

  const centerX = canvas.width/2;
  const centerY = 100;

  fishes.forEach(fish => {

    fish.x += fish.vx;
    fish.y += fish.vy;

    if(fish.x < 0 || fish.x > mapCols-4) fish.vx *= -1;
    if(fish.y < 0 || fish.y > mapRows-4) fish.vy *= -1;

    const pos = isoToScreen(fish.x, fish.y, tileW, tileH);

    const screenX = pos.x + centerX;
    const screenY = pos.y + centerY - tileW/4;

    ctx.fillStyle = "rgba(0,0,0,0.25)";
    ctx.beginPath();
    ctx.ellipse(screenX, screenY, tileW/5, tileH/4, 0, 0, Math.PI*2);
    ctx.fill();
  });
}

function render(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  const tileW = Math.min(canvas.width, canvas.height) / 10;
  const tileH = tileW / 2;
  const height = tileW / 2;

  for(let y=0; y<mapRows; y++){
    for(let x=0; x<mapCols; x++){
      drawTile(x, y, tileW, tileH, height, map[y][x]);
    }
  }

  drawFish(tileW, tileH);

  time += 0.05;
  requestAnimationFrame(render);
}

render();
</script>
</body>
</html>