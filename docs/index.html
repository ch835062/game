<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>擬真釣魚戰鬥畫面</title>
<style>
body{
  margin:0;
  background:#000;
  overflow:hidden;
}
canvas{ display:block; }
</style>
</head>
<body>
<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

function resize(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

// ===== 魚 =====
let fish = {
  x: 0.5,
  depth: 0.5,  // 0=水面 1=最深
  vx: 0.002,
  vdepth: 0.0008
};

// ===== 張力模擬 =====
let tension = 0.4;

function drawLand(){
  const horizon = canvas.height * 0.25;

  ctx.fillStyle = "#3a5f2a";
  ctx.fillRect(0,0,canvas.width,horizon);

  ctx.fillStyle = "#2e4d20";
  ctx.fillRect(0,horizon-10,canvas.width,10);
}

function drawWaterSurface(){
  const horizon = canvas.height * 0.25;

  ctx.fillStyle = "#1e88e5";
  ctx.fillRect(0,horizon,canvas.width,5);
}

function drawWaterDepth(){

  const horizon = canvas.height * 0.25;

  // 漸層水深
  const gradient = ctx.createLinearGradient(
    0,horizon,
    0,canvas.height
  );

  gradient.addColorStop(0,"#2196f3");
  gradient.addColorStop(0.4,"#1565c0");
  gradient.addColorStop(0.8,"#0d47a1");
  gradient.addColorStop(1,"#061a40");

  ctx.fillStyle = gradient;
  ctx.fillRect(0,horizon,canvas.width,canvas.height);
}

function drawParticles(){
  for(let i=0;i<20;i++){
    const x = (i*83)%canvas.width;
    const y = (i*157 + performance.now()*0.02)%canvas.height;
    ctx.fillStyle = "rgba(255,255,255,0.05)";
    ctx.beginPath();
    ctx.arc(x,y,2,0,Math.PI*2);
    ctx.fill();
  }
}

function drawFish(){

  const horizon = canvas.height * 0.25;
  const waterHeight = canvas.height - horizon;

  // 更新魚位置
  fish.x += fish.vx;
  fish.depth += fish.vdepth;

  if(fish.x<0.1 || fish.x>0.9) fish.vx *= -1;
  if(fish.depth<0.1 || fish.depth>0.9) fish.vdepth *= -1;

  // 視差
  const screenX = fish.x * canvas.width;
  const screenY = horizon + fish.depth * waterHeight;

  // 深度影響大小
  const size = 40 + fish.depth*40;

  // 深度影響亮度
  const alpha = 0.8 - fish.depth*0.6;

  ctx.fillStyle = `rgba(0,0,0,${alpha})`;

  ctx.beginPath();
  ctx.ellipse(screenX,screenY,size,size*0.5,0,0,Math.PI*2);
  ctx.fill();
}

function drawLine(){

  const horizon = canvas.height * 0.25;
  const rodX = canvas.width*0.2;
  const rodY = horizon - 40;

  const fishX = fish.x * canvas.width;
  const fishY = horizon + fish.depth * (canvas.height-horizon);

  ctx.strokeStyle = "#ffffff";
  ctx.lineWidth = 2 + tension*4;

  ctx.beginPath();
  ctx.moveTo(rodX,rodY);
  ctx.lineTo(fishX,fishY);
  ctx.stroke();
}

function drawTensionMeter(){

  const x = canvas.width*0.8;
  const y = canvas.height*0.2;
  const radius = 60;

  ctx.strokeStyle = "#555";
  ctx.lineWidth = 8;
  ctx.beginPath();
  ctx.arc(x,y,radius,0,Math.PI*2);
  ctx.stroke();

  ctx.strokeStyle = tension>0.75 ? "red" : "lime";
  ctx.beginPath();
  ctx.arc(x,y,radius,-Math.PI/2, -Math.PI/2 + tension*Math.PI*2);
  ctx.stroke();
}

function updateTension(){

  // 魚深度越深拉力越大
  tension += fish.depth*0.002;

  // 自然回彈
  tension *= 0.995;

  if(tension>1) tension=1;
  if(tension<0) tension=0;
}

function render(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  drawLand();
  drawWaterDepth();
  drawWaterSurface();
  drawParticles();
  drawFish();
  drawLine();
  drawTensionMeter();

  updateTension();

  requestAnimationFrame(render);
}

render();
</script>
</body>
</html>