<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ê∞¥ÊóèÁÆ±ÊúÄÁµÇÂº∑ÂåñÁâà</title>
<style>
body{
  margin:0;
  background: linear-gradient(
    to bottom,
    hsl(205,60%,35%) 0%,
    hsl(205,50%,20%) 40%,
    hsl(205,45%,12%) 100%
  );
  overflow:hidden;
}
canvas{ display:block; }
</style>
</head>
<body>
<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

function resize(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

const mapRows = 8;
const mapCols = 8;

const topMap = [
  [1,1,1,1,1,1,1,1],
  [1,1,1,0,0,1,1,1],
  [1,1,0,0,0,0,1,1],
  [1,0,0,0,0,0,0,1],
  [0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0],
];

let time = 0;

function isoToScreen(x, y, z, tileW, tileH, tileZ){
  return {
    x: (x - y) * tileW / 2,
    y: (x + y) * tileH / 2 - z * tileZ
  };
}

function drawCube(x,y,z,tileW,tileH,tileZ,colors,heightOffset=0,alpha=1){

  ctx.globalAlpha = alpha;

  const pos = isoToScreen(x,y,z,tileW,tileH,tileZ);
  const centerX = canvas.width/2;
  const centerY = canvas.height * 0.6;

  const sx = pos.x + centerX;
  const sy = pos.y + centerY - heightOffset;

  // ‰∏äÈù¢
  ctx.fillStyle = colors.top;
  ctx.beginPath();
  ctx.moveTo(sx, sy - tileZ);
  ctx.lineTo(sx + tileW/2, sy - tileH/2 - tileZ);
  ctx.lineTo(sx, sy - tileH - tileZ);
  ctx.lineTo(sx - tileW/2, sy - tileH/2 - tileZ);
  ctx.closePath();
  ctx.fill();

  // Â∑¶Èù¢
  ctx.fillStyle = colors.left;
  ctx.beginPath();
  ctx.moveTo(sx - tileW/2, sy - tileH/2 - tileZ);
  ctx.lineTo(sx - tileW/2, sy - tileH/2);
  ctx.lineTo(sx, sy);
  ctx.lineTo(sx, sy - tileZ);
  ctx.closePath();
  ctx.fill();

  // Âè≥Èù¢
  ctx.fillStyle = colors.right;
  ctx.beginPath();
  ctx.moveTo(sx + tileW/2, sy - tileH/2 - tileZ);
  ctx.lineTo(sx + tileW/2, sy - tileH/2);
  ctx.lineTo(sx, sy);
  ctx.lineTo(sx, sy - tileZ);
  ctx.closePath();
  ctx.fill();

  ctx.globalAlpha = 1;
}

function getWaterVisual(z, maxDepth, y){

  const depthRatio = (maxDepth - z) / maxDepth;
  const baseHue = 205;

  const lightness = 72 - depthRatio * 45;
  const saturation = 75 - depthRatio * 30;

  const distanceRatio = y / (mapRows - 1);
  const alpha = 0.9 - distanceRatio * 0.6;

  return {
    colors:{
      top: `hsl(${baseHue}, ${saturation}%, ${lightness}%)`,
      left:`hsl(${baseHue}, ${saturation}%, ${lightness - 12}%)`,
      right:`hsl(${baseHue}, ${saturation}%, ${lightness - 20}%)`
    },
    alpha: alpha
  };
}

// üåë Êµ∑Â∫äÈ´òÂ∫¶ÂáΩÊï∏ÔºàÊñúÂù°ÔºãËµ∑‰ºèÔºâ
function getSeabedHeight(x,y){
  const slope = y * 0.3; // ÊñúÂù°
  const wave = Math.sin(x*0.8) * 0.8 + Math.cos(y*0.6) * 0.5;
  return Math.floor(slope + wave);
}

// üåø Êµ∑Ëçâ
function drawSeaweed(x,y,z,tileW,tileH,tileZ){

  const pos = isoToScreen(x,y,z,tileW,tileH,tileZ);
  const centerX = canvas.width/2;
  const centerY = canvas.height * 0.6;

  const sx = pos.x + centerX;
  const sy = pos.y + centerY;

  const sway = Math.sin(time*2 + x) * 5;

  ctx.strokeStyle = "rgba(20,120,60,0.8)";
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(sx, sy - tileZ/2);
  ctx.quadraticCurveTo(
    sx + sway,
    sy - tileZ - 20,
    sx + sway,
    sy - tileZ - 40
  );
  ctx.stroke();
}

function render(){

  time += 0.05;
  ctx.clearRect(0,0,canvas.width,canvas.height);

  const tileW = Math.min(canvas.width, canvas.height)/8;
  const tileH = tileW/2;
  const tileZ = tileW/2;

  const reservedTopLayers = 15;
  const totalLayers = Math.ceil(canvas.height / tileZ);
  const mapLayer = totalLayers - reservedTopLayers - 1;

  let cubes = [];

  for(let y=0; y<mapRows; y++){
    for(let x=0; x<mapCols; x++){

      const seabedHeight = getSeabedHeight(x,y);

      // üåë Êµ∑Â∫ä
      cubes.push({
        x,y,
        z: seabedHeight,
        type:"seabed",
        depth: x+y+seabedHeight
      });

      // üåø Êµ∑Ëçâ
      if(Math.random() < 0.15){
        cubes.push({
          x,y,
          z: seabedHeight+1,
          type:"seaweed",
          depth: x+y+seabedHeight+1
        });
      }

      // üåä Ê∞¥
      for(let z=seabedHeight+1; z<mapLayer; z++){
        cubes.push({
          x,y,z,
          type:"water",
          depth: x+y+z
        });
      }

      // üü© Âú∞Âúñ
      cubes.push({
        x,y,
        z:mapLayer,
        type: topMap[y][x] ? "land":"water",
        depth:x+y+mapLayer
      });
    }
  }

  cubes.sort((a,b)=>a.depth-b.depth);

  cubes.forEach(c=>{

    if(c.type==="seabed"){
      const grain = 30 + Math.random()*20;
      drawCube(c.x,c.y,c.z,tileW,tileH,tileZ,{
        top:`hsl(30,40%,${grain}%)`,
        left:`hsl(30,35%,${grain-10}%)`,
        right:`hsl(30,35%,${grain-18}%)`
      });
    }

    else if(c.type==="seaweed"){
      drawSeaweed(c.x,c.y,c.z,tileW,tileH,tileZ);
    }

    else if(c.type==="land"){
      drawCube(c.x,c.y,c.z,tileW,tileH,tileZ,{
        top:"#4caf50",
        left:"#388e3c",
        right:"#2e7d32"
      });
    }

    else{
      const water = getWaterVisual(c.z,mapLayer,c.y);

      let waveOffset = 0;
      if(c.z===mapLayer){
        const amplitude = tileZ * 0.18;
        waveOffset = Math.sin(time + c.x*0.6 + c.y*0.6) * amplitude;
      }

      drawCube(
        c.x,c.y,c.z,
        tileW,tileH,tileZ,
        water.colors,
        waveOffset,
        water.alpha
      );
    }
  });

  requestAnimationFrame(render);
}

render();
</script>
</body>
</html>