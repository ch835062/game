<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<title>WebGL 真3D水體</title>
<style>
body{margin:0;overflow:hidden;background:#0b0f14;}
</style>
</head>
<body>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0b0f14);

const camera = new THREE.PerspectiveCamera(
  60,
  window.innerWidth/window.innerHeight,
  0.1,
  1000
);
camera.position.set(20,25,20);
camera.lookAt(0,0,0);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

window.addEventListener("resize", ()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// ===== 光源 =====
const light = new THREE.DirectionalLight(0xffffff,1.2);
light.position.set(10,20,10);
light.castShadow = true;
scene.add(light);

scene.add(new THREE.AmbientLight(0x404040,0.6));

// ===== 地圖 =====
const size = 8;
const depthLayers = 20;
const reservedTop = 15;
const mapLayer = depthLayers - reservedTop - 1;

const geometry = new THREE.BoxGeometry(1,1,1);

const landMaterial = new THREE.MeshStandardMaterial({
  color:0x4caf50
});

function getWaterMaterial(depthRatio){
  return new THREE.MeshStandardMaterial({
    color: new THREE.Color(`hsl(205,70%,${60 - depthRatio*40}%)`),
    transparent:true,
    opacity:0.9 - depthRatio*0.6,
    roughness:0.3,
    metalness:0.1
  });
}

// ===== 建立世界 =====
const cubes = [];

for(let z=0; z<depthLayers; z++){
  for(let x=0; x<size; x++){
    for(let y=0; y<size; y++){

      if(z > mapLayer) continue;

      let material;

      if(z === mapLayer){
        material = landMaterial;
      }else{
        const depthRatio = (mapLayer - z)/mapLayer;
        material = getWaterMaterial(depthRatio);
      }

      const cube = new THREE.Mesh(geometry, material);
      cube.position.set(x - size/2, z, y - size/2);
      cube.castShadow = true;
      cube.receiveShadow = true;

      scene.add(cube);
      cubes.push({mesh:cube, z});
    }
  }
}

// ===== 水面波動 =====
let time = 0;

function animate(){
  requestAnimationFrame(animate);
  time += 0.03;

  cubes.forEach(obj=>{
    if(obj.z === mapLayer){
      const x = obj.mesh.position.x;
      const y = obj.mesh.position.z;
      obj.mesh.position.y =
        obj.z +
        Math.sin(time + x*0.6 + y*0.6)*0.2;
    }
  });

  renderer.render(scene,camera);
}

animate();
</script>

</body>
</html>